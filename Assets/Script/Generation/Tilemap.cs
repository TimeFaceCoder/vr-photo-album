using UnityEngine;
using System.Collections.Generic;

public class Tilemap : MonoBehaviour {

	const float TileLength=2;
	int rows,columns;	

	public GameObject picturePrefab;
	Tile [][] tileGrid;	

	// Use this for initialization
	void Start () {
//		ReadTileMapFile("Assets/Script/Generation/tilemap.csv");//relative to the project

		Album album=GenerateFictitiousAlbum(20);
		double maxFrameWidth=TileLength*1.5;
		double maxFrameHeight=TileLength;
		ImageBank imageBank=new ImageBank(album,maxFrameWidth,maxFrameHeight);
		LayoutStrategy layoutStrategy=new BlockLayoutStrategy();
		this.tileGrid=layoutStrategy.BuildLayout(imageBank,TileLength);
		this.rows=this.tileGrid.Length;
		this.columns=this.tileGrid[0].Length;
		MakeHoleInTheFirst3Tiles();
		BuildFromTilemap();
	}
	
	// Update is called once per frame
	void Update () {
		
	}

	private Album GenerateFictitiousAlbum(int numberOfPhotos){
		Album fictitiousAlbum=new Album();
		fictitiousAlbum.name="Fictious";
		fictitiousAlbum.path="-";

		int []widths={320,640,720,1024,1280,1366,1600,1680,1920};
		int []heights={200,348,350,480,768,1024,1050,1200};


		Photo [] photoList=new Photo[numberOfPhotos];
		for (int i=0;i<numberOfPhotos;i++){
			Photo photo=new Photo();
			photo.name="Dummy Photo # "+(i+1);
			photo.description="This photo was generated by code for testing purposes";
			photo.width=widths[Random.Range(0,widths.Length)];
			photo.height=heights[Random.Range(0,heights.Length)];

			photoList[i]=photo;
		}
		fictitiousAlbum.photoList=photoList;
		return fictitiousAlbum;
	}

	private void MakeHoleInTheFirst3Tiles(){		
		int i=0;
		while(tileGrid[0][i]==null){
			i++;
		}
		tileGrid[0][i].floor.type=FloorType.Wall;
		tileGrid[0][i].floor.direction=Direction.East;

		tileGrid[0][i+1].floor.type=FloorType.Blank;

		tileGrid[0][i+2].floor.type=FloorType.Wall;
		tileGrid[0][i+2].floor.direction=Direction.West;

	}

	public static  void PrintTileMap(Tile [][]grid,int tr,int tc){
		for(int i=0;i<tr;i++){
			string rowString="";
			for(int j=0;j<tc;j++){
				rowString+=" "+grid[i][j].floor.ToString();
			}
			Debug.Log(rowString);
		}
	}

	private void BuildFromTilemap(){
		string containerPath="Tilemap/";//we might also have several themes which can be put in seperate folders

		float startX=0;
		float startY=0;

		for(int i=0;i<rows;i++){
			for(int j=0;j<columns;j++){
				if(tileGrid[i][j]==null){
					continue;
				}
				Tile tile=tileGrid[i][j];
				tile.x=startX+j*TileLength;
				tile.y=startY+i*TileLength;
				//load Floor prefab
				string floorPath=containerPath+"Floor/"+Floor.StringFor(tile.floor.type);
				GameObject floorObject=Instantiate(Resources.Load(floorPath,typeof(GameObject))) as GameObject;
				floorObject.transform.position=new Vector3(tile.x,0,tile.y);
				floorObject.transform.Rotate(0,AngleFor(tile.floor.direction),0,Space.Self);

				//load Ceiling prefab
				string ceilingPath=containerPath+"Ceiling/"+Ceiling.StringFor(tile.ceiling.type);
				GameObject ceilingObject=Instantiate(Resources.Load(ceilingPath,typeof(GameObject))) as GameObject;
				ceilingObject.transform.position=new Vector3(tile.x,0,tile.y);
				ceilingObject.transform.Rotate(0,AngleFor(tile.ceiling.direction),0);
				
			}
		}		

		//make image containers by looking for continious walls and doors
		List<ImageContainer> imageContainerList=MakeImageContainers();

		//go throught each image container and make a prefab at those positions
		PlacePhotosIn(imageContainerList);
	}

	private void PlacePhotosIn(List<ImageContainer> list){
		if(list.Count==0){
			return;
		}
		foreach(ImageContainer imageContainer in list){
			//compute the x and y that lies in the middle of the spanning tiles
			double x=(imageContainer.startTile.x+imageContainer.endTile.x)/2;
			double y=(imageContainer.startTile.y+imageContainer.endTile.y)/2;
			// load the prefab and place it here
			GameObject pictureFrame=(GameObject)Object.Instantiate(picturePrefab,new Vector3((float)x,0,(float)y),Quaternion.identity);
			PictureInfo pictureInfo=pictureFrame.GetComponent<PictureInfo>();
			Destroy(pictureInfo);
		}

	}

	private List<ImageContainer> MakeImageContainers(){
		List<ImageContainer> imageContainerList=new List<ImageContainer>();
		for(int i=0;i<rows;i++){
			for(int j=0;j<columns;j++){

				//look for walls or corners of same angle
				Tile tile=tileGrid[i][j];
				if(tile==null||tile.imageContainer!=null){
					continue;
				}
				//depending on the angle, check the adjacent tiles
				Tile before=null;
				Tile after=null;
				if(tile.floor.direction==Direction.North||tile.floor.direction==Direction.South){
					//check for tiles above and below

					if(i>0){
						before=tileGrid[i-1][j];
					}
					if(i<rows-1){
						after=tileGrid[i+1][j];
					}
				}else{
					//check for tiles left and right
					if(j>0){
						before=tileGrid[i][j-1];
					}
					if(j<columns-1){
						after=tileGrid[i][j+1];
					}
				}
				if(before!=null && before.imageContainer==null && FacingSameDirection(tile,before)){
					ImageContainer imageContainer=new ImageContainer(before,tile);				
					before.imageContainer=imageContainer;
					tile.imageContainer=imageContainer;
					imageContainerList.Add(imageContainer);
				}else if(after!=null && after.imageContainer==null && FacingSameDirection(after,tile)){
					ImageContainer imageContainer=new ImageContainer(tile,after);				
					after.imageContainer=imageContainer;
					tile.imageContainer=imageContainer;
					imageContainerList.Add(imageContainer);
				}
			}
		}
		return imageContainerList;
	}

	private bool FacingSameDirection(Tile tile1,Tile tile2){
		if(tile1.floor.type==FloorType.Wall && tile2.floor.type==FloorType.Wall){
			return tile1.floor.direction==tile2.floor.direction;
		}else if(tile1.floor.type==FloorType.Wall && tile2.floor.type==FloorType.Corner){
			return ((tile1.floor.direction==NextDirection(tile2.floor.direction)) ||
				(tile1.floor.direction==PreviousDirection(tile2.floor.direction)));
		}else if(tile1.floor.type==FloorType.Corner && tile2.floor.type==FloorType.Wall){
			return ((tile2.floor.direction==NextDirection(tile1.floor.direction)) ||
				(tile2.floor.direction==PreviousDirection(tile1.floor.direction)));
		}
		return false;
	}

	private Direction NextDirection(Direction direction){
		switch(direction){
			case Direction.North:
				return Direction.East;
			case Direction.East:
				return Direction.South;
			case Direction.South:
				return Direction.West;
			case Direction.West:
				return Direction.North;
			default:
				return Direction.North;
		}
	}

	private Direction PreviousDirection(Direction direction){
		switch(direction){
		case Direction.North:
			return Direction.West;
		case Direction.East:
			return Direction.North;
		case Direction.South:
			return Direction.East;
		case Direction.West:
			return Direction.South;
		default:
			return Direction.North;
		}
	}

	private int NextTileAngle(int tileAngle){
		if(tileAngle<270){
			return tileAngle+90;
		}else{
			return 0;
		}
	}

	private int PreviousTileAngle(int tileAngle){
		if(tileAngle>0){
			return tileAngle-90;
		}else{
			return 270;
		}
	}

	private void ReadTileMapFile(string path){
		//read the contents of a CSV file
		string csv=System.IO.File.ReadAllText(path);//must be in the same folder

		//split each new line
		string [] lines=csv.Split("\n"[0]);

		//first line contains the size of the grid
		string []dimensions=lines[0].Split(',');
		rows=int.Parse(dimensions[0]);
		columns=int.Parse(dimensions[1]);

		tileGrid=new Tile[rows][];

		//instantiate the row of tiles first
		for(int i=0;i<rows;i++){
			tileGrid[i]=new Tile[columns];	
		}


		TileLayer currentTileLayer=TileLayer.FloorMap;//default
		int currentMapRow=0;

		for (int i=1;i<lines.Length;i++){
						
			string []tiles=lines[i].Split(',');

			//beginning of each grid contains the type: floormap, ceilingmap, propmap
			if(string.Equals(tiles[0],"FloorMap")){
				currentTileLayer=TileLayer.FloorMap;
				currentMapRow=0;
			}else if(string.Equals(tiles[0],"PropMap")){
				currentTileLayer=TileLayer.PropMap;
				currentMapRow=0;
			}else if(string.Equals(tiles[0],"CeilingMap")){
				currentTileLayer=TileLayer.CeilingMap;
				currentMapRow=0;
			}else{
				//this means its a continuation of the currentTileLayer
				for(int j=0;j<columns;j++){

					if(tileGrid[currentMapRow][j]==null){
						tileGrid[currentMapRow][j]=new Tile();
					}

					if(tileGrid[currentMapRow][j]==null){
						tileGrid[currentMapRow][j]=new Tile();
					}

					switch(currentTileLayer){
						case TileLayer.FloorMap:
							tileGrid[currentMapRow][j].floor=Floor.GetTile(tiles[j]);
							break;
						case TileLayer.CeilingMap:
							tileGrid[currentMapRow][j].ceiling=Ceiling.GetTile(tiles[j]);
							break;
						case TileLayer.PropMap:
							tileGrid[currentMapRow][j].prop=Prop.GetTile(tiles[j]);
							break;
							
					}
					
				}
				currentMapRow++;
			}
			
		}
	}

	public static Direction GetDirection(int angle){
		switch(angle){
			case 0:return Direction.North;
			case 90:return Direction.East;
			case 180:return Direction.South;
			case 270:return Direction.West;
			default:
				Debug.Log("Invalid angle for direction "+angle);
				return Direction.North;
		}
	}

	public static int AngleFor(Direction direction){
		switch(direction){
			case Direction.North:
				return 0;
			case Direction.East:
				return 90;
			case Direction.South:
				return 180;
			case Direction.West:
				return 270;
			default:
				return -1;//indicates unknown,although its a valid angle, this is mostly useful while debugging
		}
	} 
}

public enum Direction{
	North,
	East,
	South,
	West
}